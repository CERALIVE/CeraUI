<script lang="ts">
import { getTranslationByKey, LL } from '@ceraui/i18n/svelte';
import { toast } from 'svelte-sonner';

import { autoSelectNextOption } from '$lib/components/streaming/StreamingAutoSelection';
import {
	buildStreamingConfig,
	startStreamingWithConfig,
} from '$lib/components/streaming/StreamingConfigService';
// Import new modular components
import { createStreamingStateManager } from '$lib/components/streaming/StreamingStateManager';
import {
	getSortedResolutions,
	normalizeValue,
	updateMaxBitrate,
} from '$lib/components/streaming/StreamingUtils';
import { validateStreamingForm } from '$lib/components/streaming/StreamingValidation';
import { parsePipelineName } from '$lib/helpers/PipelineHelper';
import type { AudioCodecs } from '$lib/helpers/SystemHelper';
import { stopStreaming } from '$lib/helpers/SystemHelper';
import type { PipelinesMessage } from '$lib/types/socket-messages';
import AudioCard from '$main/shared/AudioCard.svelte';
import EncoderCard from '$main/shared/EncoderCard.svelte';
import ServerCard from '$main/shared/ServerCard.svelte';
import StreamingControls from '$main/shared/StreamingControls.svelte';

type Properties = {
	inputMode: string | undefined;
	encoder: string | undefined;
	resolution: string | undefined;
	framerate: string | undefined;
	pipeline: keyof PipelinesMessage | undefined;
	bitrate: number | undefined;
	bitrateOverlay: boolean | undefined;
	audioSource: string | undefined;
	audioCodec: AudioCodecs | undefined;
	audioDelay: number | undefined;
	relayServer: string | undefined;
	relayAccount: string | undefined;
	srtlaServerAddress: string | undefined;
	srtlaServerPort: number | undefined;
	srtStreamId: string | undefined;
	srtLatency: number | undefined;
};

// for selected preload
type InitialSelectedProperties = Pick<
	Properties,
	'audioSource' | 'pipeline' | 'audioCodec' | 'audioDelay' | 'bitrate' | 'bitrateOverlay'
>;

// Create state manager
const stateManager = createStreamingStateManager();

// Extract stores for reactive access
const { savedConfigStore } = stateManager;
const { relayMessageStore } = stateManager;
const { unparsedPipelinesStore } = stateManager;
const { audioCodecsStore } = stateManager;
const { groupedPipelinesStore } = stateManager;
const { isStreamingStore } = stateManager;
const { audioSourcesStore } = stateManager;
const { notAvailableAudioSourceStore } = stateManager;

let properties: Properties = $state({
	bitrate: undefined,
	bitrateOverlay: false,
	audioCodec: undefined,
	audioDelay: 0,
	audioSource: undefined,
	encoder: undefined,
	framerate: undefined,
	inputMode: undefined,
	pipeline: undefined,
	relayAccount: undefined,
	relayServer: undefined,
	resolution: undefined,
	srtlaServerAddress: undefined,
	srtlaServerPort: undefined,
	srtLatency: undefined,
	srtStreamId: undefined,
});

const initialSelectedProperties: InitialSelectedProperties = $state({
	audioDelay: undefined,
	audioSource: undefined,
	pipeline: undefined,
	audioCodec: undefined,
	bitrate: undefined,
	bitrateOverlay: false,
});

// Form state
let formErrors = $state<Record<string, string>>({});

// Flags to prevent effects from overriding user selections
let isProgrammaticChange = $state(false);

// Track which specific fields user has touched (per-field interaction tracking)
let srtlaAddressTouched = $state(false);
let srtlaPortTouched = $state(false);
let srtStreamIdTouched = $state(false);

// Track encoder-related user interactions (separate from ServerCard)
let userHasInteracted = $state(false);


// Track initial restoration phase to prevent premature userHasInteracted setting
let isInitialMount = $state(true);

// Allow initial restoration to complete before tracking user interactions
$effect(() => {
	if (isInitialMount && $savedConfigStore && properties.pipeline) {
		// Wait for initial state restoration to complete
		setTimeout(() => {
			isInitialMount = false;
		}, 100);
	}
});

// React to saved config changes and initialize properties
$effect(() => {
	if ($savedConfigStore) {
		const config = $savedConfigStore;

		if (properties.srtLatency === undefined) {
			properties.srtLatency = config.srt_latency ?? 2000;
		}

		// Only restore fields that user hasn't specifically touched
		if (!srtlaPortTouched && properties.srtlaServerPort === undefined && config.srtla_port) {
			properties.srtlaServerPort = config.srtla_port;
		}

		if (!srtStreamIdTouched && !properties.srtStreamId && config.srt_streamid) {
			properties.srtStreamId = config.srt_streamid;
		}

		if (!srtlaAddressTouched && !properties.srtlaServerAddress && config.srtla_addr) {
			properties.srtlaServerAddress = config.srtla_addr;
		}

		if (initialSelectedProperties.audioDelay === undefined) {
			properties.audioDelay = initialSelectedProperties.audioDelay = config.delay ?? 0;
		}
		if (!initialSelectedProperties.pipeline) {
			initialSelectedProperties.pipeline = config.pipeline;
			properties.pipeline = config.pipeline;
		}
		if (!initialSelectedProperties.bitrate) {
			properties.bitrate = initialSelectedProperties.bitrate = config?.max_br ?? 5000;
		}

		if (!initialSelectedProperties.bitrateOverlay) {
			properties.bitrateOverlay = initialSelectedProperties.bitrateOverlay =
				config?.bitrate_overlay ?? false;
		}
		if (!initialSelectedProperties.audioSource) {
			properties.audioSource = initialSelectedProperties.audioSource = config?.asrc ?? '';
		}
		if (!initialSelectedProperties.audioCodec) {
			properties.audioCodec = initialSelectedProperties.audioCodec = config.acodec as AudioCodecs;
		}
	}
});

// React to relay server changes
$effect(() => {
	if ($relayMessageStore && $savedConfigStore !== undefined && $savedConfigStore.relay_server) {
		properties.relayServer = $savedConfigStore.relay_server ? $savedConfigStore.relay_server : '-1';
		if ($savedConfigStore?.relay_account !== undefined) {
			properties.relayAccount = $savedConfigStore.relay_account;
		}
	} else {
		properties.relayServer = '-1';
		properties.relayAccount = '-1';
	}
});

// Parse pipeline to populate encoder fields (during init or programmatic changes, not user interaction)
$effect.pre(() => {
	const canRun =
		properties.pipeline &&
		$unparsedPipelinesStore !== undefined &&
		$LL &&
		(!userHasInteracted || isProgrammaticChange);

	if (
		properties.pipeline &&
		$unparsedPipelinesStore !== undefined &&
		$LL &&
		(!userHasInteracted || isProgrammaticChange)
	) {
		const pipelineData = $unparsedPipelinesStore[properties.pipeline];
		if (!pipelineData) {
			return;
		}

		const parsedPipeline = parsePipelineName(pipelineData.name, {
			matchDeviceResolution: $LL.settings.matchDeviceResolution(),
			matchDeviceOutput: $LL.settings.matchDeviceOutput(),
		});

		properties.inputMode = parsedPipeline.format ?? undefined;
		properties.encoder = parsedPipeline.encoder ?? undefined;
		properties.resolution = parsedPipeline.resolution ?? undefined;
		properties.framerate = parsedPipeline.fps?.toString() ?? undefined;

		// Auto-select aac as default audio codec if pipeline supports audio and no codec is selected
		if (pipelineData.acodec && !properties.audioCodec && $audioCodecsStore) {
			const aacCodec = Object.keys($audioCodecsStore).find(
				(codec) => codec.toLowerCase() === 'aac',
			);
			if (aacCodec) {
				properties.audioCodec = aacCodec as AudioCodecs;
			}
		}
	}
});


$effect(() => {
	// During initial mount, don't interfere with pipeline restoration
	if (isInitialMount) {
		console.log('🔵 Pipeline validation: Skipping during initial mount');
		return;
	}

	console.log('🔍 Pipeline validation triggered:', {
		inputMode: properties.inputMode,
		encoder: properties.encoder,
		resolution: properties.resolution,
		framerate: properties.framerate,
		pipeline: properties.pipeline,
	});

	// Minimal validation effect - just clear pipeline when incomplete
	// All validation, auto-selection, and pipeline building is now handled in autoSelectNextOption
	if (
		!properties.inputMode ||
		!properties.encoder ||
		!properties.resolution ||
		!properties.framerate
	) {
		if (properties.pipeline) {
			console.log('⚠️ Incomplete combination - clearing pipeline');
			properties.pipeline = undefined;
		}
	}
});

// Updated helper to use modular validation
function validateForm() {
	const result = validateStreamingForm(
		{
			inputMode: properties.inputMode,
			encoder: properties.encoder,
			resolution: properties.resolution,
			framerate: properties.framerate,
			bitrate: properties.bitrate,
			relayServer: properties.relayServer,
			srtlaServerAddress: properties.srtlaServerAddress,
			srtlaServerPort: properties.srtlaServerPort,
		},
		(key) => getTranslationByKey($LL, key),
	);

	formErrors = result.errors;
	return result.isValid;
}

// Updated helper to use modular update function
const handleMaxBitrateUpdate = () => {
	updateMaxBitrate(properties.bitrate, $isStreamingStore);
};

// Local framerate sorter to match EncoderCard's expected signature
type MinimalPipeline = { extraction: { fps?: string | null } };
const getSortedFramerates = (framerates: MinimalPipeline[]): MinimalPipeline[] => {
	return [...framerates].sort((a, b) => {
		const fpsA = a.extraction.fps;
		const fpsB = b.extraction.fps;
		if (typeof fpsA === 'string' && fpsA.toLowerCase().includes('match')) return -1;
		if (typeof fpsB === 'string' && fpsB.toLowerCase().includes('match')) return 1;
		const numA = parseFloat(String(fpsA));
		const numB = parseFloat(String(fpsB));
		const safeA = Number.isFinite(numA) ? numA : 0;
		const safeB = Number.isFinite(numB) ? numB : 0;
		return safeA - safeB;
	});
};

function onSubmitStreamingForm(event: Event) {
	event.preventDefault();

	if (!validateForm()) {
		return;
	}

	startStreamingWithCurrentConfig();
}

const startStreamingWithCurrentConfig = () => {
	// Try to dismiss all toasts first
	try {
		toast.dismiss();
	} catch (error) {
		console.warn('Could not dismiss toasts:', error);
	}

	// Ensure a pipeline is built before attempting to start
	if (
		!properties.pipeline &&
		properties.inputMode &&
		properties.encoder &&
		properties.resolution &&
		properties.framerate &&
		$groupedPipelinesStore
	) {
		const result = autoSelectNextOption('framerate', properties, $groupedPipelinesStore);
		properties = Object.assign({}, properties, result);
	}

	const config = buildStreamingConfig(properties, { unparsedPipelines: $unparsedPipelinesStore });


	if (config) {
		startStreamingWithConfig(config);
	} else {
		toast.error('Unable to start streaming: incomplete or invalid selection.', {
			description: 'Please ensure input mode, encoder, resolution, and framerate form a valid pipeline.',
		});
	}
};

// Auto-selection handlers using modular functions
const handleInputModeChange = (value: string) => {
	// Only mark user interaction if not during initial restoration
	if (!isInitialMount) {
		userHasInteracted = true; // Mark that user has made a selection
	}
	isProgrammaticChange = true;

	console.log(
		'🔄 InputMode changed - starting unified validation/auto-selection/pipeline building',
	);

	// Unified flow: validate → clean → auto-select → build pipeline
	if (value && $groupedPipelinesStore) {
		// Create properties with new value for investigation
		const updatedProperties = { ...properties, inputMode: value };
		const result = autoSelectNextOption('inputMode', updatedProperties, $groupedPipelinesStore);

		// GUARANTEED REACTIVITY - Create completely new object
		properties = Object.assign({}, properties, { inputMode: value }, result);
		console.log('🎯 Unified flow complete - object replacement:', result);
	} else {
		// Just update the inputMode if no grouped pipelines
		properties = { ...properties, inputMode: value };
	}
	isProgrammaticChange = false;
};

const handleEncoderChange = (value: string) => {
	// Only mark user interaction if not during initial restoration
	if (!isInitialMount) {
		userHasInteracted = true; // Mark that user has made a selection
	}
	isProgrammaticChange = true;

	console.log('🔄 Encoder changed - starting unified validation/auto-selection/pipeline building');

	// Unified flow: validate → clean → auto-select → build pipeline
	if (value && $groupedPipelinesStore) {
		const updatedProperties = { ...properties, encoder: value };
		const result = autoSelectNextOption('encoder', updatedProperties, $groupedPipelinesStore);

		// GUARANTEED REACTIVITY - Create completely new object
		properties = Object.assign({}, properties, { encoder: value }, result);
		console.log('🎯 Unified flow complete - object replacement:', result);
	} else {
		properties = { ...properties, encoder: value };
	}
	isProgrammaticChange = false;
};

const handleResolutionChange = (value: string) => {
	// Only mark user interaction if not during initial restoration
	if (!isInitialMount) {
		userHasInteracted = true; // Mark that user has made a selection
	}
	isProgrammaticChange = true;

	console.log(
		'🔄 Resolution changed - starting unified validation/auto-selection/pipeline building',
	);

	// Unified flow: validate → clean → auto-select → build pipeline
	if (value && $groupedPipelinesStore) {
		const updatedProperties = { ...properties, resolution: value };
		const result = autoSelectNextOption('resolution', updatedProperties, $groupedPipelinesStore);

		// GUARANTEED REACTIVITY - Create completely new object
		properties = Object.assign({}, properties, { resolution: value }, result);
		console.log('🎯 Unified flow complete - object replacement:', result);
	} else {
		properties = { ...properties, resolution: value };
	}
	isProgrammaticChange = false;
};

// Also mark user interaction for framerate changes
const handleFramerateChange = (value: string) => {
	// Only mark user interaction if not during initial restoration
	if (!isInitialMount) {
		userHasInteracted = true; // Mark that user has made a selection
	}
	isProgrammaticChange = true;

	console.log('🔄 Framerate changed - starting unified validation/pipeline building');

	// Unified flow: validate → build pipeline
	if (value && $groupedPipelinesStore) {
		const updatedProperties = { ...properties, framerate: value };
		const result = autoSelectNextOption('framerate', updatedProperties, $groupedPipelinesStore);

		// GUARANTEED REACTIVITY - Create completely new object
		properties = Object.assign({}, properties, { framerate: value }, result);
		console.log('🎯 Unified flow complete - object replacement:', result);
	} else {
		properties = { ...properties, framerate: value };
	}
	isProgrammaticChange = false;
};
</script>

<div class="from-background via-background to-accent/5 bg-gradient-to-br">
	<form class="relative" onsubmit={onSubmitStreamingForm}>
		<!-- Streaming Controls - Sticky Header -->
		<StreamingControls
			disabled={false}
			isStreaming={!!$isStreamingStore}
			onStart={startStreamingWithCurrentConfig}
			onStop={() => {
				// Try to dismiss all toasts first
				try {
					toast.dismiss();
				} catch (error) {
					console.warn('Could not dismiss toasts:', error);
				}

				// Stop streaming with proper toast cleanup via the global function
				if (window.stopStreamingWithNotificationClear) {
					window.stopStreamingWithNotificationClear();
				} else {
					// Fallback
					stopStreaming();
				}
			}}
		/>

		<!-- Main Content Area -->
		<div class="container mx-auto max-w-6xl px-4 py-6">
			<!-- Enhanced Grid Layout with equal heights -->
			<div class="grid gap-6 lg:grid-cols-3">
				<!-- Encoder Settings Card -->
				<div class="h-full">
					<EncoderCard
						{formErrors}
						{getSortedFramerates}
						{getSortedResolutions}
						groupedPipelines={$groupedPipelinesStore}
						isStreaming={!!$isStreamingStore}
						{normalizeValue}
						onBitrateChange={(value) => (properties.bitrate = value)}
						onBitrateOverlayChange={(checked) => (properties.bitrateOverlay = checked)}
						onEncoderChange={handleEncoderChange}
						onFramerateChange={handleFramerateChange}
						onInputModeChange={handleInputModeChange}
						onResolutionChange={handleResolutionChange}
						properties={{
							inputMode: properties.inputMode,
							encoder: properties.encoder,
							resolution: properties.resolution,
							framerate: properties.framerate,
							bitrate: properties.bitrate,
							bitrateOverlay: properties.bitrateOverlay,
						}}
						updateMaxBitrate={handleMaxBitrateUpdate}
					/>
				</div>

				<!-- Audio Settings Card -->
				<div class="h-full">
					<AudioCard
						audioCodecs={$audioCodecsStore}
						audioSources={$audioSourcesStore}
						isStreaming={!!$isStreamingStore}
						{normalizeValue}
						notAvailableAudioSource={$notAvailableAudioSourceStore}
						onAudioCodecChange={(value) => (properties.audioCodec = value as AudioCodecs)}
						onAudioDelayChange={(value) => (properties.audioDelay = value)}
						onAudioSourceChange={(value) => (properties.audioSource = value)}
						properties={{
							pipeline: properties.pipeline,
							audioSource: properties.audioSource,
							audioCodec: properties.audioCodec,
							audioDelay: properties.audioDelay,
						}}
						unparsedPipelines={$unparsedPipelinesStore}
					/>
				</div>

				<!-- Server Settings Card -->
				<div class="h-full">
					<ServerCard
						{formErrors}
						isStreaming={!!$isStreamingStore}
						{normalizeValue}
						onRelayAccountChange={(value) => (properties.relayAccount = value)}
						onRelayServerChange={(value) => {
							properties.relayServer = value;
							if (value === '-1') {
								properties.relayAccount = undefined;
							}
						}}
						onSrtLatencyChange={(value) => {
							properties.srtLatency = value;
						}}
						onSrtStreamIdChange={(value) => {
							properties.srtStreamId = value;
							srtStreamIdTouched = true;
						}}
						onSrtlaAddressChange={(value) => {
							properties.srtlaServerAddress = value;
							srtlaAddressTouched = true;
						}}
						onSrtlaPortChange={(value) => {
							properties.srtlaServerPort = value;
							srtlaPortTouched = true;
						}}
						properties={{
							relayServer: properties.relayServer,
							relayAccount: properties.relayAccount,
							srtlaServerAddress: properties.srtlaServerAddress,
							srtlaServerPort: properties.srtlaServerPort,
							srtStreamId: properties.srtStreamId,
							srtLatency: properties.srtLatency,
						}}
						relayMessage={$relayMessageStore}
					/>
				</div>
			</div>
		</div>
	</form>
</div>
